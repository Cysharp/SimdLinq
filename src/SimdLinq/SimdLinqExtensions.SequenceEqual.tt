<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var signature = "public static bool SequenceEqual";
    var types = new []
    {
        "byte", "sbyte", "short", "ushort", "int", "uint", "long", "ulong", "float", "double"
    };
#>
namespace SimdLinq;

using System.Runtime.InteropServices;

// SequenceEqual<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) and if T is bitwise equatable, using SIMD.

public static partial class SimdLinqExtensions
{
<# foreach(var type in types) { #>
    <#= signature #>(<#= type #>[] first, <#= type #>[] second)
    {
        return MemoryExtensions.SequenceEqual(first.AsSpan(), second.AsSpan());
    }

    <#= signature #>(<#= type #>[] first, ReadOnlySpan<<#= type #>> second)
    {
        return MemoryExtensions.SequenceEqual(first.AsSpan(), second);
    }

    <#= signature #>(List<<#= type #>> first, List<<#= type #>> second)
    {
        return MemoryExtensions.SequenceEqual((ReadOnlySpan<<#= type #>>)CollectionsMarshal.AsSpan(first), (ReadOnlySpan<<#= type #>>)CollectionsMarshal.AsSpan(second));
    }

    <#= signature #>(List<<#= type #>> first, ReadOnlySpan<<#= type #>> second)
    {
        return MemoryExtensions.SequenceEqual((ReadOnlySpan<<#= type #>>)CollectionsMarshal.AsSpan(first), second);
    }

    <#= signature #>(Memory<<#= type #>> first, Memory<<#= type #>> second)
    {
        return MemoryExtensions.SequenceEqual((ReadOnlySpan<<#= type #>>)first.Span, (ReadOnlySpan<<#= type #>>)second.Span);
    }

    <#= signature #>(Memory<<#= type #>> first, ReadOnlySpan<<#= type #>> second)
    {
        return MemoryExtensions.SequenceEqual((ReadOnlySpan<<#= type #>>)first.Span, second);
    }

    <#= signature #>(ReadOnlyMemory<<#= type #>> first, ReadOnlyMemory<<#= type #>> second)
    {
        return MemoryExtensions.SequenceEqual(first.Span, second.Span);
    }

    <#= signature #>(ReadOnlyMemory<<#= type #>> first, ReadOnlySpan<<#= type #>> second)
    {
        return MemoryExtensions.SequenceEqual(first.Span, second);
    }

    <#= signature #>(Span<<#= type #>> first, Span<<#= type #>> second)
    {
        return MemoryExtensions.SequenceEqual((ReadOnlySpan<<#= type #>>)first, (ReadOnlySpan<<#= type #>>)second);
    }

    <#= signature #>(Span<<#= type #>> first, ReadOnlySpan<<#= type #>> second)
    {
        return MemoryExtensions.SequenceEqual((ReadOnlySpan<<#= type #>>)first, second);
    }

<# } #>
}
